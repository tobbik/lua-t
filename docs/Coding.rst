Coding Standards and Convention
+++++++++++++++++++++++++++++++


Code organization
=================

As mentioned in the README.rst, lua-t is organized by a rigid naming and
structure convention which allowed me to keep control over the code base when it
was under heavy development load.  Understanding and following these conventions
allows to read the code base faster and be more productive in it.  This is true
for bug fixing and for writing new functionality.  This guide illustrates the
conventions and makes them transparent and understandable.  It is highly
recommended to read the guide before studying the code base itself.


Naming conventions
------------------

Code generally is all put into the 'src' directory and added to its Makefile.
Each file should be prefixed with "t_".  Each "Problem Space" lua-t adressess
is assigned a three character code.  Each subproblems is assigned another three
character code, allowing for a hierarchy which can be serialized as a string.
For example, he Encoding class has 'enc' assigned to it.  The code within
Encoding to provide Base64 has 'b64' assigned to it.  From the Lua side the
Base64 object is available via T.Encoding.Base64.  Within C the files are named
after the tree character code like so:

  - t_enc.c
  - t_enc_b64.c
  - t_enc_crc.c

All functions belonging to a namespace are prefixed the same way.  Confining it
to 3 characters keeps it short, assigning exactly 3 character code to one
problem keeps it precise.


File organization
-----------------

Most classes are represented as Lua userdata in lua-t.  For most of the C part
of the code these are mainly structs.  As a result, for any userdata definition
regarding a namespace and it's subspaces all of the struct definitions should
go into the main header file for the namespace, in the above example that would
be t_enc.h.  This ensures that all data definition within a namespace AND it's
subspaces can interact with each other.


OOP interface
=============

The majority of this guide will use the eample namespace 'nry' which within Lua
then is known as 'Numarray'.  The Numarray example is explained in detail by
Roberto Ierusalimschy's book "Programming in Lua', also known as PiL.  This
guide assumes that lua-t was loaded by::

  T = require( "t" )


High-Level overview and Constructors
------------------------------------

lua-t uses a unified OOP type according to Lua-Users style guide for classes
with constructors.  A new instance of the Numarray class would be instantiated
by these two ways::

  myNry1 = T.Numarray.new( param )
  myNry2 = T.Numarray( param )

Where applicable, meta-methods should be hooked up to the instances to ease
coding. For example if useful '#myNry1' should be return a value and if
possible if myNry1==myNry2 should provide a reasonable result for the
comparison.


C File structure
================

Naming conventions
------------------

The prefixes for functions and data types signal the following conditions:

 - t               --> part of the t library
 - t_nry           --> part of the t_nry class
 - lt_nry          --> exposed to the Lua API

t_nry_* functions would be usually exposed to t_nry.h and such available
from other code that can interact with t_nry type variables.  Most lt_nry...
functions will remain static as they are accessed within the class only.


Exposure Level on Lua side
--------------------------

In general, a capitalized function name signals a function which is static to
the Lua class and a non capitalized name indicates a method on a class
instance.  A single underscore before the name indicates a direct call by name,
a double underscore signals that a metatable is involved.

lt_nry_Func
  static method on t.Numarray (eg. t.Numarray.New)

lt_nry__Func 
  metatable function of t.Numarray such as t.Numarray( ) (__call method)

lt_nry_func
  method of t.Numarray instance such as myNry:func( )

lt_nry__func
  metatable method of t.Numarray instance (#myNry length)


Data type conventions
----------------------

struct t_nry { ..., ..., ...  };
   A struct defining the userdata generated by t.Numarray( ). This is typically defined
   in a file called t_nry.h


Functional conventions
----------------------

There are some special functions each C file(class) *shall* povide. They are used
for creating and testing Lua userdata.  

static int lt_nry__Call( L )
  t.Numarray( p1, p2 ) styled constructor
static int lt_nry_New( L )
  t.Numarray.New( p1, p2 ) styled constructor
struct nry = t_nry_create_ud( L, sz ):
  Create a userdata of type t.Numarray with size sz and push onto stack, shall
  return a pointer to nry struct.  This function would be typically called from
  lt_nry_new( L ) after it evaluated the parameters passed from Lua and used
  here to populate dthe struct nry.
struct nry = t_nry_check_ud( L, pos, check ):
  Check element on stack pos for to be a userdata of type nry (t.Numarray).  If
  check==1 hard fail (lua_error) otherwise fail soft and return NULL pointer.
  If successful return pointer to nry struct.
static int lt_nry__gc( L )
  If t_nry_create_ud() would run some allocations or require a resource then
  this method must exist for clean up resources when the Numarray instance gets
  garbage collected.
LUA_API int luaopen_t_nry( L )
  A function which is called from the src/t.c file which registers 'Numarray' in
  the "t" namespace and makes "t.Numarray" and all it's functionality available.

There are some typical functions each C file(class) *should* provide.  They are
used for programmers convenience and the ability to use most of Lua's
capabilities:

static int lt_nry__len( L )
  return a meaningful #nry value
static int lt_nry__tostring( luaVM )
  returns string "t.Numarray{length}: 0x123456". It usually returns the memory
  address as well

There are functions a C file(class) *can* provide.  They are usually used to
provide methods on class instances or static functions on the class itself:

lt_nry_Doit( L )
  t.Numarray.Doit( p2 ) static method
lt_nry_read( L )
  myNry:read( p ) instance method
lt_nry_write( L )
  myNry:write( p, 2 ) instance method


Library conventions
-------------------

This convention describes how all the functionality is organized and hooked up
to Lua itself.  lua-t makes heavy use of Lua's internal way of doing it but
formalizes it somewhat.  It creates 3 struct luaL_Reg arrays which get hooked up
in the luaopen_t_nry( L ) function. ::

  // Numarray class metamethods library definition 
  static const struct luaL_Reg t_nry_fm [] = {
  	{ "__call",        lt_nry__Call},
  	{ NULL,            NULL}
  };

  // Numarray class functions library definition
  static const struct luaL_Reg t_nry_cf [] = {
  	{ "new",       lt_nry_New },
  	{ NULL, NULL }
  };

  // Numarray object method library definition
  //Assigns Lua available names to C-functions on T.Numarray instances
  static const luaL_Reg t_nry_m [] = {
  	{ "__index",    lt_nry__index },
  	{ "__newindex", lt_nry__newindex },
  	{ "__len",      lt_nry__len },
  	{ "__tostring", lt_nry__tostring },
  	// normal methods -> __index has logic to figure out if an access to the
  	// array or the method library was desired
  	{ "reverse",    lt_nry_reverse },
  	// allow metamethods to be accessed in a more traditional OOP style
  	// since those are function pointers there is very little overhead
  	{ "length",     lt_nry__len },
  	{ "toString",   lt_nry__tostring },
  	{ NULL, NULL }
  };

  // creates Metatable with methods for objects
  // creates Metatable with functions for class and push on stack to put on "t."
  LUAMOD_API int luaopen_t_nry( lua_State *L )
  {
  	// T.Numarray stance metatable
  	luaL_newmetatable( L, "T.Numarray" );
  	luaL_setfuncs( L, t_nry_m, 0 );
  	lua_pop( L, 1 );        // remove metatable from stack

  	// T.Numarray class
  	luaL_newlib( L, t_nry_cf );
  	luaL_newlib( L, t_nry_fm );
  	lua_setmetatable( L, -2 );
  	return 1;
  }
